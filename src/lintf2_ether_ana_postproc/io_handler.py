"""Functions for input/output handling."""

# Standard libraries
import os
import shutil
import sys
import uuid
from datetime import datetime

# Third-party libraries
import mdtools as mdt
import numpy as np
import pyedr

# First-party libraries
import lintf2_ether_ana_postproc as leap


def run_time_info():
    """
    Generate some run time information.

    Returns
    -------
    script_name : str
        The name of the running script.
    command_line : str
        The command line input used to start the script.
    cwd : str
        The working directory the script was started from.
    exe : str
        The exact call of the executable script.
    version : str
        The used version of lintf2_ether_ana_postproc.
    version_py : str
        The used Python version.

    See Also
    --------
    :func:`lintf2_ether_ana_postproc.io_handler.run_time_info_str` :
        Create a string containing some run time information
    """
    script_name = str(os.path.basename(sys.argv[0]))
    command_line = script_name + " " + " ".join(sys.argv[1:])
    version_py = ".".join(str(i) for i in sys.version_info[:3])
    return (
        script_name,
        command_line,
        os.getcwd(),
        sys.argv[0],
        leap.__version__,
        version_py,
    )


def run_time_info_str(indent=0):
    """
    Create a string containing some run time information.

    The string can be printed directly to standard output using
    :func:`print`.

    The information contained in the string is:

        * The date and time this function was called.
        * The copyright notice of lintf2_ether_ana_postproc.
        * The information generated by
          :func:`lintf2_ether_ana_postproc.io_handler.run_time_info`.

    Parameters
    ----------
    indent : int, optional
        Number of spaces to indent the information string.  Negative
        indentation is treated as zero indentation.

    Returns
    -------
    rti : str
        Human readable string containing the above listed content.

    See Also
    --------
    :func:`lintf2_ether_ana_postproc.io_handler.run_time_info` :
        Generate some run time information
    :func:`lintf2_ether_ana_postproc.io_handler.header_str` :
        Create a string containing some run time information to be used
        as header for text files
    """
    timestamp = datetime.now()
    script, command_line, cwd, exe, version, version_py = run_time_info()
    rti = "{}\n".format(script)
    rti += "{}\n".format(timestamp.strftime("%Y/%m/%d %H:%M"))
    rti += "\n"
    rti += leap.__copyright_notice__ + "\n"
    rti += "\n"
    rti += "\n"
    rti += "Command line input:\n"
    rti += "  {}\n".format(command_line)
    rti += "Working directory:\n"
    rti += "  {}\n".format(cwd)
    rti += "Executable:\n"
    rti += "  {}\n".format(exe)
    rti += "{} version:\n".format(leap.__title__)
    rti += "  {}\n".format(version)
    rti += "Python version:\n"
    rti += "  {}".format(version_py)
    if indent > 0:
        rti = mdt.fh.indent(rti, amount=indent, char=" ")
    return rti


def header_str():
    """
    Create a standard header string for text files.

    The string can be printed directly to standard output using
    :func:`print`.

    The header string contains:

        * The date and time the text file was created (actually this
          function was called).
        * The information generated by
          :func:`lintf2_ether_ana_postproc.file_handler.run_time_info`.

    Returns
    -------
    header : str
        Human readable string containing the above listed content.

    See Also
    --------
    :func:`lintf2_ether_ana_postproc.io_handler.run_time_info_str` :
        Create a string containing some run time information
    """
    timestamp = datetime.now()
    script, command_line, cwd, exe, version, version_py = run_time_info()
    header = "Created by {} on {}\n".format(
        script, timestamp.strftime("%Y/%m/%d %H:%M:%S")
    )
    header += "\n"
    header += leap.__copyright_notice__ + "\n"
    header += "\n"
    header += "Command line input:\n"
    header += "  {}\n".format(command_line)
    header += "Working directory:\n"
    header += "  {}\n".format(cwd)
    header += "Executable:\n"
    header += "  {}\n".format(exe)
    header += "{} version:\n".format(leap.__title__)
    header += "  {}\n".format(version)
    header += "Python version:\n"
    header += "  {}\n".format(version_py)
    return header


def write_header(fname, **kwargs):
    """
    Write the standard lintf2_ether_ana_postproc header to file.

    See :func:`lintf2_ether_ana_postproc.io_handler.header_str` for
    further information about what is contained in the header.

    Parameters
    ----------
    fname : str or bytes or os.PathLike
        The name of the file to which to write the header.
    kwargs : dict, optional
        Additional keyword arguments to parse to
        :func:`mdtools.file_handler.xopen`.  See there for possible
        arguments and their description.  By default, `mode` is set to
        ``'wt'`` (open file for writing in text mode, truncating the
        file first).

    See Also
    --------
    :func:`lintf2_ether_ana_postproc.io_handler.header_str` :
        Create a standard header string for text files
    """
    kwargs.setdefault("mode", "wt")
    with mdt.fh.xopen(fname, **kwargs) as outfile:
        outfile.write(
            mdt.fh.indent(leap.io_handler.header_str(), amount=1, char="# ")
        )


def savetxt(fname, data, rename=True, **kwargs):
    """
    Save an array to a text file.

    Parameters
    ----------
    fname : str or os.PathLike
        The name of the file to create.
    data : array_like
        1- or 2-dimensional array of data to be saved.
    rename : bool, optional
        If ``True`` and a file called `fname` already exists, rename it
        to ``'fname.bak_timestamp'``.  See
        :func:`mdtools.file_handler.backup` for more details.
    kwargs : dict, optional
        Additional keyword arguments to parse to :func:`numpy.savetxt`.
        See there for possible arguments and their description.  By
        default, `fmt` is set to ``'%16.9e'``.

    See Also
    --------
    :func:`numpy.savetxt` :
        Save an array to a text file
    :func:`lintf2_ether_ana_postproc.io_handler.header_str` :
        Create a standard header string for text files

    Notes
    -----
    This function simply calls :func:`numpy.savetxt` and adds a
    lintf2_ether_ana_postproc specific header to the output file.  See
    :func:`lintf2_ether_ana_postproc.io_handler.header_str` for further
    information about what is included in the header.
    """
    fname = os.fspath(fname)
    kwargs.setdefault("fmt", "%16.9e")
    header = kwargs.pop("header", None)
    if header is None or header.strip() == "":
        header = leap.io_handler.header_str()
    else:
        header = leap.io_handler.header_str() + "\n\n" + header
    kwargs["header"] = header
    if rename:
        mdt.fh.backup(fname)
    np.savetxt(fname, data, **kwargs)


def decompress_edr(fname):
    """
    Decompress a compressed `Gromacs .edr file
    <https://manual.gromacs.org/current/reference-manual/file-formats.html#edr>`_.

    Check if the given .edr file is compressed and if so, decompress it.

    Parameters
    ----------
    fname : str or os.PathLike
        Name of the Gromacs .edr file.

    Returns
    -------
    fname_decompressed : str or os.PathLike
        Name of the decompressed .edr file.  If the input file is
        already decompressed, `fname` is returned.

    Notes
    -----
    The check for compression relies on the file extension.  If the
    given file name ends with ".edr", it is considered to be already
    decompressed, else it is considered to be compressed.

    If the input file is decompressed, the name of the decompressed file
    is given by the name of the compressed file prefixed by a dot and
    appended by a universally unique identifier (UUID) and the current
    timestamp.
    """
    root, ext = os.path.splitext(fname)
    if ext == ".edr":
        # Input file is not compressed.
        fname_decompressed = fname
    else:
        root_decompressed, ext_decompressed = os.path.splitext(root)
        if ext_decompressed != ".edr":
            raise ValueError(
                "The input file does not contain the '.edr' extension:"
                " '{}'".format(fname)
            )
        path, basename = os.path.split(root_decompressed)
        timestamp = datetime.now()
        fname_decompressed = (
            "."
            + basename
            + "_uuid_"
            + str(uuid.uuid4())
            + "_date_"
            + str(timestamp.strftime("%Y-%m-%d_%H-%M-%S"))
            + ext_decompressed
        )
        fname_decompressed = os.path.join(path, fname_decompressed)
        with mdt.fh.xopen(fname, "rb") as file_in:
            with open(fname_decompressed, "wb") as file_out:
                shutil.copyfileobj(file_in, file_out)
    return fname_decompressed


def peek_edr(fname):
    """
    Print all energy terms contained in a `Gromacs .edr file
    <https://manual.gromacs.org/current/reference-manual/file-formats.html#edr>`_
    to standard output.

    Parameters
    ----------
    fname : str or os.PathLike
        Name of the Gromacs .edr file.
    """
    # Decompress .edr file if necessary.
    fname_decompressed = leap.io_handler.decompress_edr(fname)

    unit_dict = pyedr.get_unit_dictionary(fname_decompressed)
    print("Energy terms contained in '{}':".format(fname))
    for observable, unit in unit_dict.items():
        print("{} / {}".format(observable, unit))

    if fname_decompressed != fname:
        # Remove decompressed file.
        os.remove(fname_decompressed)


def read_edr(fname, observables, begin=0, end=-1, every=1, verbose=True):
    """
    Read data from a `Gromacs .edr file
    <https://manual.gromacs.org/current/reference-manual/file-formats.html#edr>`_.

    Parameters
    ----------
    fname : str or os.PathLike
        Name of the Gromacs .edr file.
    observables : array_like
        List of energy terms to read from the .edr file, e.g.
        ``["Time", "Potential", "Kinetic En.", "Total Energy",
        "Temperature", "Pressure", "Volume", "Density"]``.  Use
        :func:`lintf2_ether_ana_postproc.io_handler.peek_edr` to get an
        overview of all energy terms that are contained in the .edr
        file.
    begin : int, optional
        First frame to use from the .edr file.  Frame numbering starts
        at zero.
    end : int, optional
        Last frame to use from the .edr file (exclusive).
    every : int, optional
        Use every n-th frame from the .edr file.
    verbose : bool, optional
        If ``True``, print progress information to standard output.

    Returns
    -------
    data : dict
        A Dictionary that holds the times and the selected observables.
    units : dict
        A dictionary containing the time unit and the units of the
        selected observables.
    """
    # Decompress .edr file if necessary.
    fname_decompressed = leap.io_handler.decompress_edr(fname)

    # Read file.
    data = pyedr.edr_to_dict(fname_decompressed, verbose=verbose)
    units = pyedr.get_unit_dictionary(fname_decompressed)

    if fname_decompressed != fname:
        # Remove decompressed file.
        os.remove(fname_decompressed)

    # Get desired frames.
    n_frames_tot = len(data["Time"])
    begin, end, every, n_frames = mdt.check.frame_slicing(
        start=begin,
        stop=end,
        step=every,
        n_frames_tot=n_frames_tot,
        verbose=verbose,
    )

    # Get desired observables.
    observables = list(observables)
    for key in tuple(data.keys()):
        if key not in observables:
            data.pop(key)
            units.pop(key)
        else:
            data[key] = data[key][begin:end:every]

    return data, units
