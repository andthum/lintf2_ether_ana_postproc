#!/usr/bin/env python3

"""
Plot 2-dimensional density maps as generated by the MDTools script
`densmap.py
<https://github.com/andthum/mdtools/blob/f96f90de92866d0da0bc614ae59d3435d6263a10/scripts/structure/densmap.py>`_
"""


# Maximum Li densities.
# (Determined with the aim to set a common `vmax` for all simulations.)
#
# Surface-charge dependence.
# q0, q0.25 and q0.5: No patterns.
# q0.75: Patterns only for g1 system.
#
# Chain-length dependence (q1, r = 1/20).
# rho_max = 14.5  (g0, 155.26-159.09 A, including g0 system)
# rho_max =  7.0  (g1, 139.25-143.32 A, excluding g0 system)
#
# Concentration dependence (q1).
# g1:    rho_max =  8.0  (r = 1/4, 193.32-197.40 A)
# g4:    rho_max = 11.5  (r = 2/5, 224.59-228.66 A)
# peo63: rho_max = 15.0  (r = 1/4, 166.39-170.11 A)


# Standard libraries
import argparse
import os
import re

# Third-party libraries
import mdtools as mdt
import mdtools.plot as mdtplt  # Load MDTools plot style  # noqa: F401
import numpy as np
from matplotlib import pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages

# First-party libraries
import lintf2_ether_ana_postproc as leap


# Input parameters.
parser = argparse.ArgumentParser(
    description=(
        "Plot 2-dimensional density maps as generated by the MDTools script"
        " densmap.py"
    )
)
parser.add_argument(
    "--system",
    type=str,
    required=True,
    help="Name of the simulated system, e.g. lintf2_g1_20-1_gra_q1_sc80.",
)
parser.add_argument(
    "--settings",
    type=str,
    required=False,
    default="pr_nvt423_nh",
    help=(
        "String describing the used simulation settings.  Default:"
        " %(default)s."
    ),
)
parser.add_argument(
    "--cmp",
    type=str,
    required=False,
    default="Li",
    choices=("Li", "NTf2", "ether", "NBT", "OBT", "OE"),
    help="Compound.  Default: %(default)s",
)
parser.add_argument(
    "--slab",
    type=str,
    required=True,
    help="The analyzed slab in xy plane, e.g. 0.12-3.45A.",
)
parser.add_argument(
    "--normalize",
    required=False,
    default=False,
    action="store_true",
    help=(
        "If provided, normalize the density values (z values) such that the"
        " lowest value is zero and the highest value is one."
    ),
)
args = parser.parse_args()

analysis = "densmap-z"  # Analysis name.
analysis_suffix = "_" + args.cmp  # Analysis name specification.
ana_path = os.path.join(analysis, analysis + analysis_suffix)
tool = "mdt"  # Analysis software.
outfile = (
    args.settings
    + "_"
    + args.system
    + "_"
    + analysis
    + "_"
    + args.cmp
    + "_"
    + args.slab
)
if args.normalize:
    outfile += "_normalized"
outfile += ".pdf"


print("Creating Simulation instance(s)...")
if "_gra_" in args.system:
    surfq = leap.simulation.get_surfq(args.system)
    top_path = "q%g" % surfq
else:
    surfq = None
    top_path = "bulk"
set_pat = "[0-9][0-9]_" + args.settings + "_" + args.system
Sim = leap.simulation.get_sim(args.system, set_pat, top_path)


print("Reading data...")
file_suffix = analysis + analysis_suffix + "_" + args.slab + ".txt.gz"
infile = leap.simulation.get_ana_file(Sim, ana_path, tool, file_suffix)
data = np.loadtxt(infile)
if np.any(data < 0):
    raise ValueError("At least one data point is less than zero.")
x = data[1:, 0] / 10  # Angstrom -> nm.
y = data[0, 1:] / 10  # Angstrom -> nm.
z = data[1:, 1:] * 1e3  # 1/Angstrom^3 -> 1/nm^3.
del data
# Transform the array from matrix convention (origin at upper left) to
# coordinate convention (origin at lower left).
z = np.ascontiguousarray(z.T[::-1])

if args.normalize:
    # Rescale the z values such that the lowest value is zero and the
    # hightest value is one.
    z_min = np.min(z)
    z -= z_min
    z_max = np.max(z)
    z /= z_max
else:
    # Calculate density per area.
    # 1. Get the slab width.
    # Remove all non-numeric characters from `args.slab`.
    slab_range = re.sub("[^0-9|.|-]", "", args.slab)
    # Get start and stop of the slab.
    slab_range = slab_range.split("-")
    if len(slab_range) != 2:
        raise ValueError("Invalid --slab: '{}'".format(args.slab))
    slab_range = np.array([float(slab) for slab in slab_range])
    slab_range /= 10  # Angstrom -> nm.
    slab_start, slab_stop = np.min(slab_range), np.max(slab_range)
    slab_width = slab_stop - slab_start
    if slab_width <= 0:
        raise ValueError("Invalid slab width: {}".format(slab_width))
    # 2. Multiply the density by the slab width to convert density per
    #    volume to density per area.
    z *= slab_width


print("Creating plot(s)...")
xlabel = r"$x$ / nm"
ylabel = r"$y$ / nm"
if args.normalize:
    zlabel = r"Density $\rho_{xy}$ / Arb. Unit"
    vmax = 1
else:
    zlabel = r"Density $\rho_{xy}$ / nm$^2$"
    vmax = None
xlim = (0, 1)
ylim = xlim

mdt.fh.backup(outfile)
with PdfPages(outfile) as pdf:
    fig, ax = plt.subplots(clear=True)
    # figwidth_original = fig.get_figwidth()
    # fig.set_figwidth(figwidth_original * 0.9)
    img, cbar = mdtplt.imshow_new(
        ax=ax, X=z, vmin=0, vmax=vmax, extent=(0, x.max(), 0, y.max())
    )
    ax.set(xlabel=xlabel, ylabel=ylabel)
    cbar.set_label(zlabel)
    yticks = np.asarray(ax.get_yticks())
    mask = (yticks >= ax.get_xlim()[0]) & (yticks <= ax.get_xlim()[1])
    ax.set_xticks(yticks[mask])
    pdf.savefig(fig)

    # fig.set_figwidth(figwidth_original * 0.95)
    ax.set(xlim=xlim, ylim=ylim)
    yticks = np.asarray(ax.get_yticks())
    mask = (yticks >= ax.get_xlim()[0]) & (yticks <= ax.get_xlim()[1])
    ax.set_xticks(yticks[mask])
    pdf.savefig(fig)
    plt.close(fig)

print("Created {}".format(outfile))
print("Done")
