#!/usr/bin/env python3


"""
Plot the bins generated by `generate_z-bins.py` together with the
density and free-energy profile of the specified compound.
"""


# Standard libraries
import argparse

# Third-party libraries
import matplotlib.pyplot as plt
import mdtools as mdt
import mdtools.plot as mdtplt  # Load MDTools plot style  # noqa: F401
import numpy as np
from matplotlib.backends.backend_pdf import PdfPages
from matplotlib.ticker import MaxNLocator

# First-party libraries
import lintf2_ether_ana_postproc as leap


def annotate_bins(ax, bins):
    """
    Annotate a :class:`matplotlib.axes.Axes` with bin numbers.

    Parameters
    ----------
    ax : matplotlib.axes.Axes
        The :class:`~matplotlib.axes.Axes` to annotate.
    bins : array_like
        The bin edges.
    """
    bins = np.asarray(bins)
    ax.text(
        x=np.mean(ax.get_xlim()),
        y=ax.get_ylim()[1] + 0.12 * np.diff(ax.get_ylim()),
        s="Bin Number",
        fontsize="small",
        horizontalalignment="center",
        verticalalignment="bottom",
    )
    for bin_num, bin_mid in enumerate(bins[1:] - np.diff(bins) / 2, start=1):
        if bin_num % 2 == 0:
            y_pos = ax.get_ylim()[1]
        else:
            y_pos = ax.get_ylim()[1] + 0.06 * np.diff(ax.get_ylim())
        ax.text(
            x=bin_mid,
            y=y_pos,
            s="{:^d}".format(bin_num),
            fontsize="x-small",
            horizontalalignment="center",
            verticalalignment="bottom",
        )


# Input parameters.
parser = argparse.ArgumentParser(
    description=(
        "Plot the bins generated by `generate_z-bins.py` or"
        " `generate_z-bins_bulk.py` together with the density and"
        " free-energy profile of the specified compound."
    )
)
parser.add_argument(
    "--system",
    type=str,
    required=True,
    help="Name of the simulated system, e.g. lintf2_g1_20-1_gra_q1_sc80.",
)
parser.add_argument(
    "--settings",
    type=str,
    required=False,
    default="pr_nvt423_nh",
    help=(
        "String describing the used simulation settings.  Default:"
        " %(default)s."
    ),
)
parser.add_argument(
    "--cmp",
    type=str,
    required=False,
    default="Li",
    choices=("Li", "NBT", "OBT", "OE"),
    help="Compound.  Default: %(default)s",
)
args = parser.parse_args()

analysis = "density-z"  # Analysis name.
analysis_suffix = "_number"  # Analysis name specification.
tool = "gmx"  # Analysis software.
outfile = (
    args.settings
    + "_"
    + args.system
    + "_"
    + analysis
    + analysis_suffix
    + "_"
    + args.cmp
    + "_bins.pdf"
)

# Columns to read from the file containing the density profile.
cols_dens = (0,)  # bin edges [nm]
if args.cmp == "Li":
    cols_dens += (2,)  # Li number density [nm^-3]
elif args.cmp == "NBT":
    cols_dens += (5,)  # NBT number density [nm^-3]
elif args.cmp == "OBT":
    cols_dens += (6,)  # OBT number density [nm^-3]
elif args.cmp == "OE":
    cols_dens += (7,)  # OE number density [nm^-3]
else:
    raise ValueError("Unknown --cmp ({})".format(args.cmp))

# Column to read from the file containing the bin edges.
col_bins = 0  # Bin edges [A]


print("Creating Simulation instance(s)...")
if "_gra_" in args.system:
    surfq = leap.simulation.get_surfq(args.system)
    top_path = "q%g" % surfq
else:
    surfq = None
    top_path = "bulk"
set_pat = "[0-9][0-9]_" + args.settings + "_" + args.system
Sim = leap.simulation.get_sim(args.system, set_pat, top_path)


print("Reading data...")
Elctrd = leap.simulation.Electrode()
elctrd_thk = Elctrd.ELCTRD_THK / 10  # A -> nm
box_z = Sim.box[2] / 10  # A -> nm
bulk_dens = Sim.dens["atm_type"][args.cmp]["num"]
bulk_dens *= 1e3  # 1/A^3 -> 1/nm^3

# Read density profile.
file_suffix = analysis + analysis_suffix + ".xvg.gz"
infile_dens = leap.simulation.get_ana_file(Sim, analysis, tool, file_suffix)
xdata, dens = np.loadtxt(
    infile_dens, comments=["#", "@"], usecols=cols_dens, unpack=True
)
dens /= bulk_dens

# Calculate the free-energy profile from the density profile.
bulk_region = Sim.bulk_region
bulk_region /= 10  # A -> nm
free_en = leap.misc.dens2free_energy(xdata, dens, bulk_region=Sim.bulk_region)

# Read bin edges.
file_suffix = analysis + analysis_suffix + "_" + args.cmp + "_binsA.txt.gz"
infile_bins = leap.simulation.get_ana_file(Sim, analysis, tool, file_suffix)
bins = np.loadtxt(infile_bins, usecols=col_bins)
bins /= 10  # A -> nm


print("Creating plot(s)...")
xlabel = r"$z$ / nm"
xlim = (0, box_z)

ydata = (dens, free_en)
ylabel_dens = (
    r"Density $\rho_{"
    + leap.plot.ATOM_TYPE2DISPLAY_NAME[args.cmp]
    + r"}(z) / \rho_{"
    + leap.plot.ATOM_TYPE2DISPLAY_NAME[args.cmp]
    + r"}^{bulk}$"
)
ylabel_fe = (
    r"Free Energy $F_{"
    + leap.plot.ATOM_TYPE2DISPLAY_NAME[args.cmp]
    + r"}(z)$ / $k_B T$"
)
ylabels = (ylabel_dens, ylabel_fe)
ylims_dens = ((0, None), (0, 6.5))
ylims_fe = ((None, None),)
if args.cmp == "Li":
    ylims_fe += ((-6, 7.5),)
elif args.cmp == "NBT":
    ylims_fe += ((-6, 9),)
elif args.cmp == "OBT":
    ylims_fe += ((-6, 5.5),)
elif args.cmp == "OE":
    ylims_fe += ((-2.2, 5.5),)
else:
    raise ValueError("Unknown --cmp ({})".format(args.cmp))
ylims = (ylims_dens, ylims_fe)

if surfq is None:
    legend_title = ""
else:
    legend_title = r"$\sigma_s = \pm %.2f$ $e$/nm$^2$" % surfq + "\n"
legend_title = (
    legend_title
    + r"$r = %.4f$" % Sim.Li_O_ratio
    + "\n"
    + r"$n_{EO} = %d$" % Sim.O_per_chain
)

mdt.fh.backup(outfile)
with PdfPages(outfile) as pdf:
    for dat_ix, ylims_dat_type in enumerate(ylims):
        for ylim in ylims_dat_type:
            fig, ax = plt.subplots(clear=True)
            if surfq is not None:
                leap.plot.elctrds(
                    ax, offset_left=elctrd_thk, offset_right=box_z - elctrd_thk
                )
            ax.plot(xdata, ydata[dat_ix])
            ax.set(xlabel=xlabel, ylabel=ylabels[dat_ix], xlim=xlim, ylim=ylim)
            ax.vlines(
                x=bins,
                ymin=ax.get_ylim()[0],
                ymax=ax.get_ylim()[1],
                colors="black",
                linestyles="dotted",
            )
            ax.xaxis.set_major_locator(MaxNLocator(integer=True))
            annotate_bins(ax, bins)
            legend = ax.legend(
                title=legend_title,
                loc="upper center",
                **mdtplt.LEGEND_KWARGS_XSMALL,
            )
            legend.get_title().set_multialignment("center")
            pdf.savefig()
            plt.close()

print("Created {}".format(outfile))
print("Done")
